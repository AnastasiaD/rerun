{"note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"Core rerun ","name":"Rerun","body":"# NAME\r\n\r\nrerun - a simple command runner because it's easy to forget \r\nstandard operating procedure.\r\n\r\n# SYNOPSYS\r\n\r\n\trerun [-h][-v][-V] [-M <dir>] [-L <dir>] [--replay <file>] [module:[command [options]]]\r\n\r\n# DESCRIPTION\r\n\r\nRerun is a simple command runner that turns loose shell scripts\r\ninto modular automation. Rerun will help you\r\norganize your implementation into well defined command interfaces.\r\nCollections of management modules can be archived and delivered as\r\na single executable to facilitate team hand offs.\r\nUsing the \"stubbs\" module, rerun will even facilitate unit tests.\r\nWhen users execute rerun module commands, rerun can record \r\nexecution data into log files that can later be replayed.\r\n\r\nRerun provides two modes of operation:\r\n\r\n1. *Listing*: Rerun lists modules and commands. Listing\r\ninformation includes name, description and command line usage syntax.\r\n2. *Execution*: Rerun provides option processing (possibly defaulting\r\nunspecified arguments) and executes a script for the specified module command.\r\n\r\nFor the module developer, rerun is a trivial framework following\r\nsimple conventions that easily fit in a shell environment.\r\nRerun includes a module development tool called \"stubbs\" that\r\nhelps create and evolve rerun modules. Stubbs contains\r\ncommands to automate option processing code, metadata definition\r\nand unit testing.\r\n\r\nInternally, `rerun` implements a simple dispatching mechanism to look up named\r\ncommands and execute them. *Commands* are logically named and\r\nhave a corresponding script.\r\n\r\nCommands reside in a module and can have named \r\nparameters called *options*. Each option is named,\r\ndescribed and can also be defined to use a default value \r\nor say whether it is required or not.\r\n\r\nRerun modules can also declare metadata describing name, description\r\nand other aspects of each command. Rerun makes use of this metadata\r\nto support a listing mode, a feature where modules and command usage\r\nare summarized for end users.\r\n\r\nSee the [project wiki](https://github.com/rerun/rerun/wiki)\r\nfor additional documentation including:\r\n\r\n* [Getting started](https://github.com/rerun/rerun/wiki)\r\n* [Installation](https://github.com/rerun/rerun/wiki/Installation)\r\n* [Stubbs module tool](https://github.com/rerun/rerun/tree/master/modules/stubbs)\r\n* [Why rerun?](https://github.com/rerun/rerun/wiki/Why-rerun%3F)\r\n\r\n# OPTIONS\r\n\r\n`-h`\r\n: Print help and usage then exit.\r\n\r\n`--replay *LOG*`\r\n: Compare the results of a _command_ execution to that in a replay log and show the difference in output if any.\r\n\r\n`-M` *DIRECTORY*\r\n: Module library directory path.\r\n\r\n`-L` *DIRECTORY*\r\n: Recorded _command_ execution logs stored in this directory. Also settable via `RERUN_LOGS`.\r\n\r\n`-v` \r\n: Execute _command_ in verbose mode. \r\n\r\n`-V` \r\n: Execute `rerun` and _command_ in verbose mode. \r\n\r\n\r\n# USING\r\n\r\n## Help\r\n\r\nFor command line syntax and example usage execute `rerun` using the `--help` flag:\r\n\r\n\t$ ./rerun --help\r\n\t _ __ ___ _ __ _   _ _ __\r\n\t| '__/ _ \\ '__| | | | '_ \\ \r\n\t| | |  __/ |  | |_| | | | |\r\n\t|_|  \\___|_|   \\__,_|_| |_|\r\n\tVersion: v0.1. License: Apache 2.0.\r\n\r\n\tUsage: rerun [-h][-v][-V] [-M <dir>] [-L <dir>] [--replay <file>] [module:[command [command_args]]]\r\n\r\n\tExamples:\r\n\t| $ rerun \r\n\t| => List all modules.\r\n\t| $ rerun freddy\r\n\t| => List all freddy commands.\r\n\t| $ rerun freddy:dance --jumps 3\r\n\t| => Execute the freddy:dance command.\r\n\t| $ rerun -M /var/rerun freddy:dance\r\n\t| => Execute the freddy:dance command found in /var/rerun\r\n\r\n\r\n## Listing\r\n\r\nWithout arguments, `rerun` will list existing modules:\r\n\r\n    $ rerun\r\n      freddy: \"A dancer in a red beret and matching suspenders\"\r\n\r\nTo list the commands available from the 'freddy' module run:\r\n\r\n    $ rerun freddy\r\n     study: \"tell freddy to study\"\r\n       --subject <math>: \"the summer school subject\"\r\n     dance: \"tell freddy to dance\"\r\n       --jumps <1>: \"jump #num times\"\r\n\r\nThe listing consists of info about command options \r\nincluding default values if they were described with option metadata.\r\n\r\nOptions that declare a default value are shown\r\nwith a string between the \"<>\" characters.\r\n\r\nFor example, notice how \"--jumps\" option shows `<1>`.\r\nThe \"1\" is the default value assigned to the \"--jumps\" option.\r\n\r\nSee the \"Environment\" section below to learn about the\r\n`RERUN_MODULES` environment variable. This variable\r\nspecifies the directory where rerun modules exist.\r\n\r\n### Bash completion\r\n\r\nIf you are a Bash shell user, be sure to source the `bash_completion.sh` file. \r\nIt provides listing via the tab key.\r\n\r\nType `rerun` and then the tab key. The shell will generate\r\na list of existing modules.\r\n\r\n    $ rerun[TAB][TAB]\r\n    freddy\r\n\r\nRerun shows there is a module named \"freddy\" installed.\r\n\r\nTyping the tab key again will show the commands inside the \"freddy\" module:\r\n\r\n    $ rerun freddy: [TAB]\r\n    dance  study     \r\n\r\nIn this case, two commands are found and listed. Press tab again\r\nand choose a command.\r\nAfter accepting a command, typing the tab key will show arguments.\r\n\r\n    $ rerun freddy:study -[TAB]\r\n    --subject\r\n\r\nThe `freddy:study` command accepts one option (--subject <>).\r\n    \r\n## Command execution\r\n\r\nCommands are executed by stating the module,\r\ncommand and possibly options. The basic usage form is\r\n\"`rerun` _module_:_command_ [_options_]\".\r\n\r\nTo run the \"study\" command in the freddy module, type:\r\n\r\n    $ rerun freddy:study\r\n    studying (math)\r\n\r\nThe outputed string \"studying (math)\" is the printed result. \r\nIn this example, \"math\" is the subject option's default value\r\nas defined in the module metadata.\r\n    \r\nCommand options are passed after the \"module:command\" string. \r\nTell freddy to study the subject, \"biology\" by specifying \r\nthe `--subject <>` option:\r\n\r\n    $ rerun freddy:study --subject biology\r\n    studying (biology)\r\n\r\nIf the 'freddy' module is stored in `/var/rerun`, then the command usage\r\nwould be:\r\n\r\n    $ rerun -M /var/rerun freddy:study\r\n    studying (math)\r\n\r\n### Archives\r\n\r\nAn *archive* contains all the rerun modules you need\r\n(you might have a library of them) and gives you\r\nthe same exact interface as rerun,... all in one file!\r\n\r\nSpecifically, an archive is a set of modules \r\nand `rerun` itself packaged into a self extracting\r\nscript (by default in a file named \"rerun.bin\"). \r\nArchives can be useful if you want\r\nto share a single self contained executable that contains all the needed modules.\r\n\r\nRun an archive script like you would run `rerun`.\r\n\r\nYou can execute an archive via `bash` like so:\r\n\r\n    $ bash rerun.bin <module>:<command> --your options\r\n\r\nIf the execute bit is set, invoke the archive directly.\r\n\r\nHere the archive is executed without arguments which causes the archive\r\nto list the modules contained within it.\r\n\r\n    $ ./rerun.bin\r\n      freddy: \"A dancer in a red beret and matching suspenders\"\r\n      .\r\n      . listing output ommitted\r\n\r\nNote, \".bin\" is just a suffix naming convention for a self-extracting script.\r\nThe archive file can be named anything you wish.\r\n\r\nRun the `freddy:dance` command in the archive:\r\n\r\n\t$ ./rerun.bin freddy:dance --jumps 3\r\n\tjumps (3)\r\n\r\nSee `stubbs:archive` for further information about creating and \r\nunderstanding rerun archives.\r\n\r\n### Replay\r\n\r\nRerun supports basic command replay logging (See \"Logs\" section below).\r\nWhen rerun logs a command it does so in a form that can be re-executed \r\n(i.e., \"replayed\"). It's possible to have rerun compare the results of a \r\ngiven replay log against a new command execution.\r\nReplay logs are normally found in the directory specified by the `RERUN_LOGS`\r\nenvironment variable (or the `-L <dir>` option).\r\n\r\nUse the `--replay <log>` option to compare replay output from a command log.\r\n\r\nBelow you can see the results of a comparison between this run of\r\n`freddy:dance --jumps 2`  against an earlier command execution. \r\nAfter the command completes, rerun uses the `diff` command \r\nto compare the log output.\r\n\r\n\t$ ./rerun --replay $RERUN_LOGS/freddy-dance-2011-09-21T140744.replay freddy:dance --jumps 2\r\n\tjumps (2)\r\n\t[diff]\r\n\t2c2\r\n\t< jumps ()\r\n\t---\r\n\t> jumps (2)\r\n\r\nIn this case, the replay contained \"jumps ()\" while the new\r\nexecution printed \"jumps (2)\".\r\nWhen a difference is detected, `rerun` will print the differences\r\nbelow the `[diff]` label and exit with a non-zero exit status.\r\n\r\n# LOGS\r\n\r\nRerun records command execution as replay logs, if the `-L <dir>` \r\nargument is set or the `RERUN_LOGS` environment variable is set.\r\nBe sure to set `RERUN_LOGS` to a writable directory. \r\n\r\nEach command execution is recorded in the form of a \"replay\" log\r\nfile (ending with `.replay`).\r\nThis log file contains information about the command\r\nexecution, as well as, the output from the execution.\r\n\r\nThese .replay files can be edited or executed as scripts.\r\n\r\n*File naming*\r\n\r\nEach replay log is named using the following pattern:\r\n\r\n    $RERUN_LOGS/$MODULE-$COMMAND-YYYY-MM-DD-THHMMSS-PID.replay\r\n\r\nTo list the replay logs for the `freddy:dance` command use `ls`:\r\n\r\n\t$ ls -l $RERUN_LOGS/freddy-dance*.replay\r\n\t-rw-rw----  1 alexh  wheel  188 Sep 21 19:54 freddy-dance-2011-09-21T195402-2344.replay\r\n\t\r\n\r\n*File format*\r\n\r\nReplay logs follow a simple format that combines \r\ncommand execution metadata and log output.\r\n\r\nmetadata:\r\n\r\n* RERUN: The rerun executable\r\n* MODULE: The module name\r\n* COMMAND: The command name\r\n* OPTIONS: The command options\r\n* USER: The user executing the command\r\n* DATE: The timestamp for the execution\r\n\r\nHere's the metadata as specified in the file template:\r\n\r\n\t#\r\n\t# Rerun replay log\r\n\t#\r\n\tRERUN=\"$RERUN\"\r\n\tMODULE=\"$MODULE\"\r\n\tCOMMAND=\"$COMMAND\"\r\n\tOPTIONS=\"$*\"\r\n\tUSER=\"$USER\"\r\n\tDATE=\"$(date '+%Y-%m%d-%H%M%S')\"\r\n\t__COMMAND_OUT_BELOW__\r\n\t\r\nAny command output is stored below the line delimiter, `__COMMAND_OUT_BELOW__`.\r\n\r\nHere's an example replay file for the `freddy:dance` command:\r\n\r\n\t#\r\n\t# Rerun replay log\r\n\t#\r\n\tRERUN=\"/Users/alexh/rerun-workspace/rerun/rerun\"\r\n\tMODULE=\"freddy\"\r\n\tCOMMAND=\"dance\"\r\n\tOPTIONS=\"\"\r\n\tUSER=\"alexh\"\r\n\tDATE=\"2011-0921-195402\"\r\n\t__COMMAND_OUT_BELOW__\r\n\r\n\tjumps (1)\r\n\r\nThis simple shell function will parse the content for a given \r\nreplay log:\r\n\r\n\trerun_extractLog() {\r\n\t\t[ -f $1 ] || die \"file does not exist: $1\"\r\n\t\tSIZE=$(awk '/^__COMMAND_OUT_BELOW__/ {print NR + 1; exit 0; }' $1) || die \"failed sizing output\"\r\n\t\ttail -n+$SIZE $1 || die \"failed extracting output\"\r\n\t}\r\n\r\nRunning this shell function for a given replay log looks similar to this:\r\n\r\n\t$ rerun_extractLog $RERUN_LOGS/freddy-dance-2011-0921-194512.replay\r\n\r\n\tjumps (1)\r\n\r\n\r\n# MODULES\r\n\r\n## Layout\r\n\r\nA rerun module assumes the following structure:\r\n\r\n    <MODULE>\r\n    ├── commands\r\n    │   ├── cmdA (directory for cmdA files)\r\n    │   │   ├── metadata (command metadata)\r\n    │   │   ├── default.sh (generic script)\r\n    │   │   ├── optX.option (declares metadata for \"optX\" option)\r\n    │   │   └── options.sh (option parsing script)\r\n    │   └── cmdB\r\n    │       ├── Darwin.sh (OS specific script)\r\n    │       ├── metadata\r\n    │       ├── default.sh (generic script)\r\n    │       ├── options.sh\r\n    │       └── optY.option (declares metadata for \"optY\" option)\r\n    ├── metadata (module metadata)\r\n    └── lib\r\n\r\n## Command Scripts\r\n\r\nRerun's internal dispatch logic uses the directory layout\r\ndescribed above to find and execute scripts for each command.\r\n\r\nRerun expects a default implementation script for each command\r\nbut can also invoke an OS specific script, if present.\r\n\r\n* default.sh: Generic implementation.\r\n* $(uname -s).sh: OS specific implementation\r\n* options.sh: Script sourceable by default and OS specific scripts\r\n  to parse options (also generated by stubbs).\r\n\r\n## Metadata\r\n\r\nThe metadata file format uses line separated _KEY=value_\r\npairs to define module attributes. The module metadata\r\nfile declares two properties:\r\n\r\n* NAME: Declare name displayed to user.\r\n* DESCRIPTION: Brief explanation of use.\r\n\r\nFor example, a module named `freddy` is named\r\nand described in a file called `RERUN_MODULES/freddy/metadata`:\r\n\r\n    NAME=\"freddy\"\r\n    DESCRIPTION=\"A dancer in a red beret and matching suspenders\"\r\n\r\nCommand metadata is described in a file called\r\n`RERUN_MODULES/<module>/commands/<command>/metadata`.\r\nHere's the command metadata for the \"study\" command:\r\n\r\n    NAME=\"study\"\r\n    DESCRIPTION=\"tell freddy to study\"\r\n\r\nOptions are described in a file called \r\n`RERUN_MODULES/<module>/commands/<command>/<option>.option`.\r\nBeyond just NAME and DESCRIPTION, options can also declare:\r\n\r\n* ARGUMENTS: Does the option take an argument.\r\n* REQUIRED: Is the option required.\r\n* DEFAULT: Sensible value for an option default \r\n\r\nHere's `subject.option` describing an option named \"subject\":\r\n\r\n    NAME=subject\r\n    DESCRIPTION=\"the summer school subject\"\r\n    ARGUMENTS=true\r\n    REQUIRED=true\r\n    DEFAULT=math\r\n\r\nCombining the examples above into the layout described earlier\r\nthe \"freddy\" module along with its commands \"dance\" and \"study\"\r\nare illustrated here:\r\n\r\n    freddy\r\n    ├── commands\r\n    │   ├── dance\r\n    │   │   ├── metadata\r\n    │   │   ├── default.sh\r\n    │   │   ├── jumps.option\r\n    │   │   └── options.sh\r\n    │   └── study\r\n    │       ├── metadata\r\n    │       ├── default.sh\r\n    │       ├── options.sh\r\n    │       └── subject.option\r\n    ├── metadata\r\n    └── lib\r\n\r\n# ENVIRONMENT\r\n\r\n`RERUN_MODULES`\r\n: Path to directory containing rerun modules.\r\nIf RERUN_MODULES is not set, it is defaulted\r\nrelative to the location of the rerun executable.\r\n\r\n`RERUN_LOGS`\r\n: Path to directory where rerun will record command\r\nexecutions as replay log files.\r\n\r\n`RERUN_COLOR`\r\n: Set 'true' if you want ANSI text effects. Makes\r\nlabels in text to print bold in the console.\r\nSyntax errors will also print bold.\r\n\r\n`DIFF`\r\n: Set to the particular `diff` command to use for\r\nreplay log comparisons.\r\n\r\n# SEE ALSO\r\n\r\nTo create modules, see\r\n[stubbs](https://github.com/rerun/rerun/tree/master/modules/stubbs).\r\n\r\n# ERROR CODE\r\n\r\n`0`\r\n: All commands executed successfully\r\n\r\n`1`\r\n: One or more commands failed\r\n\r\n`127`\r\n: Unknown error case\r\n\r\n# LICENSE\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); \r\nyou may not use this file except in compliance with the License. \r\nYou may obtain a copy of the License at\r\n\r\nhttp://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, \r\nsoftware distributed under the License is distributed on an \r\n\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, \r\neither express or implied. See the License for the specific \r\nlanguage governing permissions and limitations under the License.\r\n\r\nThe rerun source code and all documentation may be downloaded from\r\n<https://github.com/rerun/rerun/>.\r\n","google":""}