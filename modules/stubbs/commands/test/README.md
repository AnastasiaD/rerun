Use *stubbs:test* to run test plans for your module.

Stubbs provides support for unit testing modules 
through the use of [roundup](http://bmizerany.github.com/roundup/). 
Stubbs includes roundup, so it's not necessary for you 
to provide a global install 
(unless you want to in which case you should!). 

Running tests
-------------

Each module can contain any number of test plans
but one will be created by default by 
[stubbs:add-command](../add-command/index.html).

You can create as many test plans as you wish and use
stubbs:test to run them as you evolve your command implementations.

To run all test plans for freddy, run:

    rerun stubbs:test --module freddy

The `test` command will print output similar to the following:

    =========================================================
     TESTING MODULE: freddy 
    =========================================================
    dance
      it_fails_without_a_real_test:                    [FAIL]
    =========================================================
    Tests:    1 | Passed:   0 | Failed:   1

A successful unit test will print "PASS" while a 
failed one will print "FAIL" and cause stubbs:test to exit non zero.

Running just one test plan
--------------------------

Use the `--plan` option to execute the tests for
the "dance" command.

    rerun stubbs:test --module freddy --plan dance

The stubbs:test command assumes a file naming convention for
the test plan scripts:

    <plan>-<number>-test.sh

* plan: the test plan name. usually the command name (eg, "dance")
* number: plans can be grouped by plan name and organized by a number.
This example describes how to write a test.

Writing your tests
------------------

Each test plan is written as a 
[roundup](http://bmizerany.github.com/roundup/) script.
Each roundup test plan is a simple script that contains 
test functions. Each test function is prefixed with `it_`. 
Roundup extracts these "`it_`" functions and runs them in a 
sandbox. Tests should return with a 0 (zero) upon 
successful test validation. Non-zero causes the test 
to fail.
The implementation of the individual test scripts are 
completely open to anything the author wishes to do.

Here's an example script that began as a boiler plate 
generated by [add-command](../add-command/index.html). 
Notice how this script contains several rough sections:

File listing: `$RERUN_MODULES/freddy/tests/dance-1-test.sh`

    #!/usr/bin/env roundup
    #
    # This file contains test scripts to run for the dance command.
    # Execute it by invoking: 
    #    
    #/ usage: rerun stubbs:test -m freddy -c dance
    
    # Helpers
    # ------------

    # The Plan
    # --------
     
    describe "dance"
     
    it_should_print_jumps() {
        expr "$(rerun freddy:dance)" : "jumps.*"
    }

This test plan declares a single test called, 
`it_should_print_jumps`. This test invokes freddy:dance
and uses the `expr` command to match the output to 
a pattern. If the output matches, the test succeeds.

If setup and tear down procedures are needed, create a 
`before` and/or `after` function in your test plan. 
Roundup runs these _before_ and _after_ functions
between each of your `it_` functions.

Roundup doesn't declare special assertion functions because
roundup encourages you to make use of the Unix shell's
natural assertion commands: `test` and `expr`.
See the [test](http://ss64.com/bash/test.html)
and [expr](http://ss64.com/bash/expr.html) 
commands to declare assertions.
