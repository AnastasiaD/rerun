#!/usr/bin/env bash

if [[ -z "$RERUN_MODULES" ]]; then
    echo >&2 "RERUN_MODULES not defined"
    exit 1
fi

set -e

LIBDIR=$(dirname $(dirname $0))
. $LIBDIR/functions.sh || exit 1

[ $# = 3 ] || { 
    echo >&2 "usage: $0 <moddir> <module> <command>" 
    exit 1 ; 
}
moddir=$1 module=$2 command=$3

# list the options that set a default
optionsWithDefaults=$(stubbs_options_matching $moddir/$module $command DEFAULT='[[:alnum:]]+')

# list the options that are required
optionsRequired=$(stubbs_options_matching $moddir/$module $command REQUIRED=true)

# list the options that have variables to export
optionsExported=$(stubbs_options_matching $moddir/$module $command EXPORT=true)

generate_option_parser(){
    local optName=$1
    local optVarname=$(stubbs_option_variable $optName)
    local ARGUMENTS=$(stubbs_option_property $moddir/$module $optName ARGUMENTS)
    local SHORT=$(stubbs_option_property $moddir/$module $optName SHORT)
    if [ -n "${SHORT}" ] 
    then
        argstring=$(printf ' case ~/--%s|-%s/:' "${optName}"  "${SHORT}")
    else
        argstring=$(printf " case ~/--%s/:" "${optName}" )
    fi
    if [ "$ARGUMENTS" == "false" ]
    then
        printf " %s\n parsed['%s']=true \n break\n" "${argstring}" "$optName"
    else
        printf " %s\n def opt='%s'\nif(i+1>=args.length){\n usageError(opt) \n}\n parsed[opt]=args[++i] \nbreak\n" \
            "$argstring" "$optName"
    fi
}
    
(
    cat <<EOF
#!/usr/bin/env groovy
/*
# Generated by stubbs:add-option. Do not edit, if using stubbs.
# Created: $(date)
#
#/ usage: $module:$command $(stubbs_command_usage $moddir/$module $command)
*/
class OptsParser{
    static names="$(rerun_options $moddir $module $command)".split(' ') as List
    static required="$optionsRequired".split(' ') as List
    static exported="$optionsExported".split(' ') as List
    static defaults=[
    $(for opt in $(echo $optionsWithDefaults|sort); do
printf "'%s':'%s',\n" $opt $(stubbs_option_property $moddir/$module $opt DEFAULT)
done)
    ]
    static usage='''
#/ usage: $module:$command $(stubbs_command_usage $moddir/$module $command)
'''.substring(4)
    def options=[:]
    def getAt(key){ options[key] }
    def propertyMissing(String key){ options[key] }
    def propertyMissing(String key, value) { options[key] = value }
    static usageError(opt){
        System.err.println usage
        throw new RuntimeException("Usage error: "+opt)
    }
    static parse(args){
        def parsed=[:]
        for(def i=0;i<args.length;i++){
            switch(args[i]){
$(for o in $(rerun_options $moddir $module $command); do 
printf "      %s\n" "$(generate_option_parser $o)"; 
done)
                default:
                    usageError("unknown option: "+args[i])
            }
        }
        //If defaultable options variables are unset, set them to their DEFAULT
        defaults?.each{k,v-> 
            if(null==parsed[k]){parsed[k]=v}
        }
        // Check required options are set
        required?.each{opt->
            if(null==parsed[opt]){ usageError('missing required option: --'+opt)}
        }
        // If option variables are declared exportable, export them.
        exported?.findAll{parsed[it]}.each{opt->
            System.properties['RERUN_OPTION:'+opt]=parsed[opt]
        }
        new OptsParser(options:parsed)
    }
    public String toString(){
        return options.toString()
    }
}

OptsParser.parse(args)
EOF
) 
    # generated to stdout

