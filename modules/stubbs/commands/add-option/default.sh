#!/bin/bash

# Source common function library
. $RERUN_MODULES/stubbs/lib/command.sh

# Init the handler
rerun_init 

# Get the options
while [ "$#" -gt 0 ]; do
    OPT="$1"
    case "$OPT" in
        # options without arguments
	# options with arguments
	-name)
	    arg_syntax_check "$#"
	    NAME="$2"
	    shift
	    ;;
	-description)
	    arg_syntax_check "$#"
	    DESC="$2"
	    shift
	    ;;
	-command)
	    arg_syntax_check "$#"
	    COMMAND="$2"
	    shift
	    ;;
	-module)
	    arg_syntax_check "$#"
	    MODULE="$2"
	    shift
	    ;;
	-req)
	    arg_syntax_check "$#"
	    REQ="$2"
	    shift
	    ;;
	-args)
	    arg_syntax_check "$#"
	    ARGS="$2"
	    shift
	    ;;
	-default)
	    arg_syntax_check "$#"
	    DEFAULT="$2"
	    shift
	    ;;
        # unknown option
	-?)
	    syntax_error
	    ;;
	  # end of options, just arguments left
	*)
	    break
    esac
    shift
done

# Post process the options
[ -z "$NAME" ] && {
    echo "Name: "
    read NAME
}

[ -z "$DESC" ] && {
    echo "Description: "
    read DESC
}

[ -z "$MODULE" ] && {
    echo "Module: "
    select MODULE in $(rerun_modules $RERUN_MODULES);
    do
	echo "You picked module $MODULE ($REPLY)"
	break
    done
}

[ -z "$COMMAND" ] && {
    echo "Command: "
    select COMMAND in $(rerun_commands $RERUN_MODULES $MODULE);
    do
	echo "You picked command $COMMAND ($REPLY)"
	break
    done
}


# Generate metadata for new option

(
    cat <<EOF
# generated by add-option
# $(date)
NAME=$NAME
DESCRIPTION="$DESC"
ARGUMENTS=${ARGS:-true}
REQUIRED=${REQ:-true}
DEFAULT=$DEFAULT

EOF
) > $RERUN_MODULES/$MODULE/commands/$COMMAND/$NAME.option || error


options=$(echo $(rerun_options $RERUN_MODULES $MODULE $COMMAND)|sort|tr '[:lower:]' '[:upper:]')
optionsWithDefaults=
for opt in $(rerun_options $RERUN_MODULES $MODULE $COMMAND); do
    default=$(rerun_optionDefault $RERUN_MODULES $MODULE $COMMAND $opt)
    [ -n "$default" ] && optionsWithDefaults="$optionsWithDefaults $opt"
done

# Generate option parser script.

(
cat <<EOF
# generated by add-option
# $(date)

# print error message and exit non-zero
arg_syntax_error() {
    echo "SYNTAX ERROR" >&2 ; exit 2;
}
# check option has its argument
arg_syntax_check() {
    [ "\$1" -lt 2 ] && syntax_error
}

# options: [$(rerun_options $RERUN_MODULES $MODULE $COMMAND)]
while [ "\$#" -gt 0 ]; do
    OPT="\$1"
    case "\$OPT" in
       $(for o in $(rerun_options $RERUN_MODULES $MODULE $COMMAND); do printf "%8s\n" "$(rerun_optionparser $o)"; done)
        # unknown option
        -?)
            arg_syntax_error
            ;;
        # end of options, just arguments left
        *)
          break
    esac
    shift
done

# If cli options unset, set them to default value
$(for opt in $(echo $optionsWithDefaults|sort|tr '[:lower:]' '[:upper:]'); do
printf "[ -z \"$%s\" ] && { %s=%s ; }" $opt $opt $(rerun_optionDefault $RERUN_MODULES $MODULE $COMMAND $opt)
done)
EOF
) > $RERUN_MODULES/$MODULE/commands/$COMMAND/options.sh || error

# Done
echo "Wrote option: $RERUN_MODULES/$MODULE/commands/$COMMAND/$NAME.option"


