#!/usr/bin/env bash
#
# **rerun** - a simple command runner because it's easy to forget 
# standard operating procedure. If you've got a bunch of loose
# unstructured shell scripts, rerun will help you
# turn them into testable automation modules.
# 
# Minimalism is rerun's goal. It will try to stay out of the way
# yet take care of some of the grunt work.
#
# __Install__
# 
# See [wiki](http://github.com/rerun/rerun/wiki) for install and
# setup instructions.
#
# Usage and Prerequsites
# ----------------------

# Rerun uses bash from the PATH to help make it more portable.
SH="/usr/bin/env bash"
# Save the name of the rerun executable to show in usage messages.
PROG=$(basename $0)
USAGE="
Usage: $PROG [-h][-v][-V] [-M <dir>] [-L <dir>] [--replay <file>] [module:[command [options]]]
"
PAD="  "

# The `diff` command is used with the --replay option to compare execution output.
# Export `DIFF` environment variable to specify a specific `diff` command.
: ${DIFF:=diff}

# Set the RERUN environment variable so subsequent 
# invocations use the same executable. 
# This helps chaining command executions across modules.
export RERUN=$0

# __Example usages__

# The `-h` option uses examples to print command usages.

examples() {
echo $(tput sgr 0 1)"Examples:$(tput sgr0)
| \$ $PROG 
| => List all modules.
| \$ $PROG freddy
| => List all freddy commands.
| \$ $PROG freddy:dance --jumps 3
| => Execute the freddy dance command."
}

# __Colorizing and text effects__

# Unset `RERUN_COLOR` to disable.
txtrst () { tput sgr0 ; }
bold() { echo -e "\033[1m$*\033[0m" ; txtrst ; }
dim() { tput dim ; echo " $*" ; txtrst ; }
[ -n "$RERUN_COLOR" ] && {
    ul="\033[4m" ; _ul="\033[0m" ; # underline
    gray="\033[38;5;238m" ; _gray="\033[0m" ; # gray
    red="\033[31m" ; _red="\033[0m" ; # red
    bold="\033[1m$*\033[0m" ; _bold="\033[0m" ; # bold
}

# __ASCII art banner__

#  Prints logo and version info with a rainbow of colors!
banner() {
echo $(tput setaf 1) " _ __ ___ _ __ _   _ _ __"
echo $(tput setaf 2) "| '__/ _ \ '__| | | | '_ \ "
echo $(tput setaf 3) "| | |  __/ |  | |_| | | | |"
echo $(tput setaf 4) "|_|  \___|_|   \__,_|_| |_|"
echo $(tput setaf 5) "Version: v0.1. License: Apache 2.0."
txtrst
}

# __Man page generator__

# Each module can have a Unix man page. 
# Use stubbs:docs to generate the man page if one doesn't
# already exist.
# Display the man page with `nroff`.
man() {
    [ ! $# = 1 ] && { 
        die "wrong # args: should be: man module" 
    }
    local module=$1
    if [ ! -f $RERUN_MODULES/$module/$module.1 \
           -a -f $RERUN_MODULES/stubbs/commands/docs/default.sh ]
    then
       $RERUN stubbs:docs --module $module 
    fi
    if [ -f $RERUN_MODULES/$module/$module.1 ]
    then
        nroff -man $RERUN_MODULES/$module/$module.1 | ${PAGER:-more}
    else
        echo "Manual could not be generated." >&2
    fi
}

# __Utility functions__

# Print the message and exit.
# Use text effects if `RERUN_COLOR` environment variable set.
die() {
    if [[ "$RERUN_COLOR" == "true" ]]
    then echo -e ${red}"ERROR: $*"${_red} >&2 
    else echo "ERROR: $*" >&2
    fi
    exit 1
}

# Print USAGE and exit.
rerun_syntax_error() {
    if [[ "$RERUN_COLOR" == "true" ]]
    then echo -e ${red}"SYNTAX: $*"${_red} >&2 
    else echo "ERROR: $*" >&2
    fi
    exit 2
}

# Check option has an argument.
rerun_syntax_check() {
    [ "$1" -lt 2 ] && rerun_syntax_error
}

# Resolve the handler script for specified command in module.
# Uses `uname -s` to get OS name for specific handlers.
# If the user created a script named after the OS,
# then print that path otherwise print the default one.
rerun_resolveCommandScript() {
    [ ! $# -eq 2 ] && { 
	    die 'wrong # args: should be: rerun_resolveCommandScript module command'
    }
    local module=$1 command=$2
    local module_dir=$RERUN_MODULES/$module
    local command_dir=$module_dir/commands/${command}
    local os=$(uname -s)
    if [ -f  "$command_dir/${os}.sh" ]
    then
        echo $command_dir/${os}.sh; 
    else
        echo $command_dir/default.sh; 
    fi
}

# Checks if handler script exists (default or otherwise).
# return 0 if exists, 1 otherwise
rerun_existsCommandScript() {
    [ ! $# -eq 2 ] && { 
	    die 'wrong # args: should be: rerun_existsCommandScript module command'
    }
    local module=$1 command=$2
    if [ -f "$(rerun_resolveCommandScript $module $command)" ]
    then return 0
    else return 1
    fi
}

# Check if module exists.
# It's a module if it has a `metadata` file in the subdirectory.
rerun_existsModule() {
    [ ! $# -eq 1 ] && { 
	    die 'wrong # args: should be: rerun_existsModule module'
    }
    local module=$1
    [ -f $RERUN_MODULES/$module/metadata ] && return 0 || return 1
}

# Extract the log data from the replay log file.
rerun_extractLog() {
    [ ! $# -eq 1 ] && { 
	    die 'wrong # args: should be: rerun_extractLog file'
    }
    local file=$1
    [ -f $file ] || { 
        die "file does not exist: $file"
    }
    local SIZE=$(awk '/^__COMMAND_OUT_BELOW__/ {print NR + 1; exit 0; }' $file) || die "failed sizing log"
    tail -n+$SIZE $file || die "failed extracting log"
}

# Lookup a metadata property value.
rerun_metadataLookup() {
    local field=$1 file=$2
    [ ! -r $file ] && { echo "file not found: $file" ; return 1 ; }
    while read line
    do
	    key=${line%%=*}
	    value=${line##*=}
        [ "$key" == "$field" ] && {
            echo $value ; break ;
	    }
    done < $file
}

rerun_catReplayMetadata() {
    (
       cat <<EOF
#
# Command replay log
#
RERUN="$0"
MODULE="$MODULE"
COMMAND="$COMMAND"
OPTIONS="$*"
USER="$USER"
DATE="$TSTAMP"
EXIT_STATUS="$RETVAL"
__COMMAND_OUT_BELOW__
       
EOF
    )
}

# Option parsing
# --------------

# There are two sets of options, `rerun` specific arguments 
# and command options.

# Check for the `RERUN_MODULES` environment variable 
# otherwise set module directory relative to the `rerun` executable.
[ -n "$RERUN_MODULES" ] || {
    RERUN_MODULES=$(cd "$(dirname "${BASH_SOURCE[0]}" )" && pwd)/modules
}

# Clear MODULE and COMMAND in case they were incidentally
# declared in the environment.
MODULE="" COMMAND=""

# Consume the `rerun` command line options first.
while [ "$#" -gt 0 ]; do
    OPT="$1"
    case "$OPT" in
	-h*|--h*)
        banner
        bold "$USAGE"
        examples		
        exit 0
	    ;;
  	-v)
	    VERBOSE="-vx"
	    ;;
  	-V)
	    VERBOSE="-vx"
	    set -vx
	    ;;
	--man*)
	    rerun_syntax_check "$#"
	    man $2
	    exit 0
	    ;;	
	-M)
	    rerun_syntax_check "$#"
	    RERUN_MODULES="$2"
	    shift
	    ;;
	-L)        
	    rerun_syntax_check "$#"
	    RERUN_LOGS="$2" ; # Record log dir.
	    shift
	    ;;	
	--replay)
	    rerun_syntax_check "$#"
	    REPLAY="$2"
	    shift
	    ;;	
	  # Ignore remaining arguments as they are for the module.
	*)
	    break
    esac
    shift
done

# Replay requires that a log directory is also set.
[ -n "$REPLAY" -a -z "$RERUN_LOGS" ] && {
    echo "Usage error: --replay <file> also requires -L <dir>" >&2 ; 
    exit 2
}

# __Parse rerun command and their options__
#
# Use regex to split up command strings.
regex='([^:]+)([:]?[ ]?)([-A-Za-z0-9_]*)([ ]*)(.*)'
if [[ "$@" =~ $regex ]]
then
    MODULE=${BASH_REMATCH[1]};    # module
    [ "${BASH_REMATCH[2]}" == ': ' ] && shift ;# eat the extra space char
    COMMAND=${BASH_REMATCH[3]/ /}; # command
    #- BASH_REMATCH[4] contains the whitespace separating command and options.
    #- BASH_REMATCH[5] contains command options.
else
    MODULE=${1/:/}                # module (minus colon)
fi
# Shift over so the remaining arguments are left to the command options.
shift; 

# Ensure the modules directory path is defined and is a directory.
[ -n "$RERUN_MODULES" -a -d "$RERUN_MODULES" ] || {
    die "RERUN_MODULES directory not found or does not exist: $RERUN_MODULES"
}


# Module and Command Listing
# --------------------------

# **rerun** provides two listing modes: module and commands.
# If a user specifies `rerun` without arguments, a listing
# of module names and their descriptions is displayed.
# If a user specifies a module name: `rerun <module>`,
# then a listing of commands and their options are displayed.

# __Module listing__ 

# If no module or command are specified, 
# display a listing of modules, showing each 
# module's name and description.
# Modules are read from the directory referenced 
# using the `$RERUN_MODULES` environment variable.
[ -z "$MODULE" -a -z "$COMMAND" ] && {
    echo -e $gray"Available modules in \"$RERUN_MODULES\":"$_gray
    for module in $RERUN_MODULES/*; do
       	$(rerun_existsModule $(basename $module)) && {
           module_name=$(basename $module)
           module_desc=$(rerun_metadataLookup DESCRIPTION $module/metadata)
           echo "${PAD}${module_name}: ${module_desc}" 
        }
    done
    exit 0
}

# __Command listing__ 

# If a module name is specified, show the command set.
# For each command, show that command's option list in summary form
# displaying requirement, name, flags, defaults and description.
[ -n "$MODULE" -a -z "$COMMAND" ] && {
    $(rerun_existsModule $MODULE) || die "module not found: $MODULE"
    echo -e $gray"Available commands in module, \"$RERUN_MODULES/$MODULE\":"$_gray
    shopt -s nullglob # enable
    for cmd in $RERUN_MODULES/$MODULE/commands/*/default.sh
	do
        cmd_name=$(basename $(dirname $cmd))
        cmd_metadata=$RERUN_MODULES/$MODULE/commands/${cmd_name}/metadata
        [ -f $cmd_metadata ] && cmd_desc=$(rerun_metadataLookup DESCRIPTION $cmd_metadata)
        bold "${cmd_name}: ${cmd_desc}"
        if [ -d $RERUN_MODULES/$MODULE/commands/${cmd_name} ]
        then            
            shopt -s nullglob # enable
            optfiles=( $RERUN_MODULES/$MODULE/commands/${cmd_name}/*.option )
            for opt_metadata in ${optfiles[*]}; do
                cmd_param=$(basename $(echo ${opt_metadata%%.option}))
                (    argstring= summary=                  
                    . $opt_metadata ; # Read the option's metadata.                    
                    [ -n "${SHORT}" ] && {                    
                       argstring=$(printf ' --%s|-%s'  "$NAME" "$SHORT")
                    } || {
                       argstring=$(printf " --%s" "$NAME" )
                    }	  
                    [ "$ARGUMENTS" == "true" ] && {
                        argstring=$(printf "%s <${ul}%s${_ul}>" "$argstring" "$DEFAULT")
                    }
                    [ "$REQUIRED" != "true" ] && {
                        summary=$(printf "[%s]: \"%s\"" "${argstring}" "$DESCRIPTION") 
                    } || {
                        summary=$(printf "%s: \"%s\"" "${argstring}" "$DESCRIPTION")
                    }
                    echo -e "$PAD $summary"
                )
            done
        fi
    done
    exit 0
}

# Command Execution
# -----------------

# There are two modes of execution: normal and replay. 
# Normal mode is what you'd expect. The handler script for the
# command is looked up an executed with user options.
# Replay mode occurs when a user specifies a replay file and
# its output is extracted and compared to a new execution.

# The module and command must be specified for execution mode.
[ -z "$MODULE"  ]  && rerun_syntax_error "module not specified"
[ -z "$COMMAND" ]  && rerun_syntax_error "command not specified"

#  Exit, if the command script is not found.
# User specified a command that did not exist in the RERUN_MODULES directory.
! rerun_existsCommandScript $MODULE $COMMAND && {
    rerun_syntax_error command not found: \"$MODULE:$COMMAND\"
}

# Ready to run. Export rerun executable environment.
export RERUN RERUN_MODULES 
export MODULE_DIR=$RERUN_MODULES/$MODULE
# Lookup the path to the command handler script.
COMMAND_SCRIPT=$(rerun_resolveCommandScript $MODULE $COMMAND)
# Source the module and command metadata.
[ -r $MODULE_DIR/metadata ] && . $MODULE_DIR/metadata
[ -r $MODULE_DIR/commands/${COMMAND}/metadata ] && {
	. $MODULE_DIR/commands/${COMMAND}/metadata
}

# If the  `-L` flag is set, record execution.
if [ -z "$RERUN_LOGS" -o ! -d "$RERUN_LOGS" ]
then
    # __Normal execution mode__
    # 

    # Execute the command script. 
    # Returns the command script's exit code as the result.

    $SH $VERBOSE $COMMAND_SCRIPT "$@"	
    RETVAL=$?
else
    # __Recorded execution mode__
    # 
    # When logging is enabled, run the command script in replay mode.
    #
    # Save a timestamp for the log.

    TSTAMP=$(date '+%Y-%m-%dT%H%M%S-%Z')
    LOG=$RERUN_LOGS/$MODULE-$COMMAND-$TSTAMP-$$.running
    # Execute the command script and direct output to the log file.
    # Get the exit code of the script execution (not the `tee` command).
    $SH $VERBOSE $COMMAND_SCRIPT "$@" | tee $LOG

    RETVAL=${PIPESTATUS[0]}
    # Generate execution metadata for the replay file.
    # This metadata describes the command execution context and is
    # sufficient to re-execute the command.
    # Output from the execution is delimited by `__COMMAND_OUT_BELOW__`.
    rerun_catReplayMetadata $@ > ${LOG%*.running}.metadata || die "Failed generating replay log."
    REPLAYLOG=$RERUN_LOGS/$MODULE-$COMMAND-$TSTAMP-$$.replay
    cat ${LOG%*.running}.metadata $LOG > $REPLAYLOG || die "Failed generating replay log."
    rm -f $LOG ${LOG%*.running}.metadata; # cleanup working files
    LOG=$REPLAYLOG
	
    # Create a symlink to the "latest" replay log.
    rm -f $RERUN_LOGS/$MODULE-$COMMAND-latest.replay; #remove old symlink
    ln -s $LOG $RERUN_LOGS/$MODULE-$COMMAND-latest.replay; # recreate it

    # Replay execution mode
    # ---------------------

    # If the `--replay` option is set, then extract the output
    # from the log file and compare it to the results of this execution.
    # Use the `diff` command to compare the two
    # and show the diff output if execution output 
    # doesn't match the replay file content.

    if [ -n "$REPLAY" ]
    then
        rerun_extractLog $REPLAY > $RERUN_LOGS/rerun-$$.checklog
        rerun_extractLog $LOG > $RERUN_LOGS/rerun-$$.log
        
        $DIFF $RERUN_LOGS/rerun-$$.checklog $RERUN_LOGS/rerun-$$.log > $RERUN_LOGS/rerun-$$.diff
        RETVAL=$?
        [ $RETVAL -eq 1 ] && {
           echo -e ${bold}"[diff]"${_bold}
            cat $RERUN_LOGS/rerun-$$.diff
        }
        rm -f $RERUN_LOGS/rerun-$$.{log,checklog,diff}
    fi
fi





# Exit with the command exit code.
exit ${RETVAL}

# Done!
